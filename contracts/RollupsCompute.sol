// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import {ICartesiDAppFactory} from "@cartesi/rollups/contracts/ICartesiDAppFactory.sol";
import {IInputBox} from "@cartesi/rollups/contracts/inputs/IInputBox.sol";


/// @title RollupsCompute
/// @notice Generic contract for creating child computation instances for a parent main Cartesi DApp
contract RollupsCompute {

    ICartesiDAppFactory internal factory;
    IInputBox internal inputBox;


    /// @notice Computation instance information
    /// @param instantiator Address that signed the transaction to create the instance
    /// @param mainDApp Address of the target application for receiving instance outputs
    /// @param templateHash Template hash for the instance's Cartesi Machine
    /// @param id Instance identifier
    struct InstanceInfo {
        address instantiator;
        address mainDApp;
        bytes32 templateHash;
        bytes32 id;
    }

    // mapping from instance address => instance info
    mapping(address => InstanceInfo) internal instances;


    /// @notice Constructor
    /// @param _factory factory to create computation instances
    /// @param _inputBox input box to send inputs to Cartesi DApps
    constructor(ICartesiDAppFactory _factory, IInputBox _inputBox) {
        this.factory = _factory;
        this.inputBox = _inputBox;
    }


    /// @notice Returns salt used to deterministically calculate instance addresses
    /// @dev Used internally by other methods for consistency
    /// @param _mainDApp Address of the target application for receiving instance outputs
    /// @param _templateHash Template hash for the instance's Cartesi Machine
    /// @param _id Instance identifier
    /// @return salt
    function calculateSalt(
        address _mainDApp,
        bytes32 _templateHash,
        bytes32 _id
    )
        internal pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(_mainDApp, _templateHash, _id));
    }


    /// @notice Calculates deterministic address for a computation instance
    /// @dev Should be called by clients to allow them to send inputs even if instance is not created
    /// @param _mainDApp Address of the target application for receiving instance outputs
    /// @param _templateHash Template hash for the instance's Cartesi Machine
    /// @param _id Instance identifier
    /// @return address
    function calculateInstanceAddress(
        address _mainDApp,
        bytes32 _templateHash,
        bytes32 _id
    )
        external view
        returns (address)
    {
        return factory.calculateApplicationAddress(
            CartesiDApp(_mainDApp).getConsensus(),
            address(this),
            _templateHash,
            this.calculateSalt(_mainDApp, _templateHash, _id)
        );
    }

    
    /// @notice Created computation instance using a deterministic address
    /// @dev Called by clients to create an instance to process inputs when necessary
    /// @param _mainDApp Address of the target application for receiving instance outputs
    /// @param _templateHash Template hash for the instance's Cartesi Machine
    /// @param _id Instance identifier
    /// @return address
    function instantiate(
        address _mainDApp,
        bytes32 _templateHash,
        bytes32 _id
    )
        external
        returns (CartesiDApp)
    {
        CartesiDApp dapp = factory.newApplication(
            CartesiDApp(_mainDApp).getConsensus(),
            address(this),
            _templateHash,
            this.calculateSalt(_mainDApp, _templateHash, _id)
        );

        // ALTERNATIVE: add input to mainDApp with instance info (instance address + instantiator + templateHash + id)
        // - in this case verifier would NOT emit a voucher to call RollupsCompute.relay(data)
        // - instead, verifier voucher would directly add an input to the mainDApp with the data
        // - problem: to do that, the verifier would need to know the mainDApp's address
        // - solution: instantiate() could also add an input to the instance with the mainDApp address (like a "setup input")
        InstanceInfo storage instance = this.instances[address(dapp)];
        instance.instantiator = msg.sender;
        instance.mainDApp = _mainDApp;
        instance.templateHash = _templateHash;
        instance.id = _id;
        
        return dapp;
    }



    /// @notice Relays data sent by a computation instance to its main Cartesi DApp 
    /// @dev Called by executing vouchers generated by the computation instance
    /// @param _data Arbitrary data sent by the computation instance back to its main DApp
    function relay(bytes _data) external {
        InstanceInfo instance = this.instances[msg.sender];

        /* 
          DATA RELAY TRUST ASSUMPTIONS AND STRATEGY:
          - Main DApp must know RollupsCompute's address: as such, it can trust inputs coming from this contract
          - Main DApp must decode input and check if `templateHash` is adequate
          - Main DApp can then trust the data for the instance specified by the given id
          - Application for scaling games:
            - Main DApp will be able to trust the data as the correct result for game 57
            - If result differs from the previously claimed value, it will slash the claimer and give part of the funds to the instantiator
            - If result confirms claim, Main DApp may slash instantiator for delaying the result confirmation (he will also bear the costs he already paid for the verification itself)
        */
        this.inputBox.addInput(
            instance.mainDApp,
            abi.encodePacked(
                instance.instantiator,
                instance.templateHash,
                instance.id,
                data
            )
        );
    }
}
